#+title: stack-vm.c
#+author: Aryadev Chavali
#+description: A simple assembler and interpreter for a stack based bytecode VM
#+date: 2023-09-16

A simple implementation of a stack based virtual machine that
assembles and interprets custom byte code, in C11.

 I don't support Windows necessarily
but I think it should be possible to build and run this using MinGW or
something as I'm not doing anything particularly Posix specific (yet).
+But honestly, why are you using Windows anyway?+

* Build instructions
Have ~make~ installed pretty please.  I'm using ~gcc~ but ~clang~ does
work as well so go crazy (edit [[file:Makefile::CC=gcc][here]] to
change the compiler).

For everything do:
#+begin_src sh
make all
#+end_src

The assembler, interpreter and unit tests are their own binaries so
you could just build the one you want specifically.
#+begin_src sh
make interpreter.out
make assembler.out
make test.out
#+end_src
* How to use
=assembler.out=: Takes two inputs:
+ File name for assembly code
+ File name for output bytecode
Then it attempts to assemble the input file given.  It does produce
errors so lookout for them.

=interpreter.out=: Takes one input:
+ File name for bytecode file
It attempts to execute the bytecode at the file given on a fresh
virtual machine instance.  Also produces errors.

=test.out=: Takes no input.  Runs unit tests.  Look for ~#define
VERBOSE_LOGS N~ and set it to 1 to produce more verbose logs.
* Tasks
** TODO [#A] Write a better in memory assembler :BYTECODE:
[[file:src/vm.c::void vm_write_program(vm_t *vm, FILE *fp)]]

We need something a bit more robust, as sometimes bytes aren't
correctly written into the binary buffer.  Also, while it looks clean,
it isn't consistent.

2023-09-19: If we implement the tagging scheme, then the assembler
just needs to write a tag byte then the n bytes for the payload.  This
works the other way for the interpreter: read the tag byte then slurp
n bytes for the payload.
** TODO [#B] Write tests [0%] :TESTS:
*** TODO [66%] Write tests for parser
[[file:tests/test-parser.c]]
**** DONE Complete test_parse_line
+ Test whitespace inclusion
[[file:tests/test-parser.c::bool test_parse_line(void)]]
**** DONE Test parse_i64
[[file:src/parser.c::perr_t parse_i64(buffer_t *buf, i64 *ret)]]
**** TODO Test parse_buffer
[[file:src/parser.c::perr_t parse_buffer(buffer_t *buf, op_t **instructions,]]
*** TODO [0%] Write tests for virtual machine implementation
In particular the assembler and interpreter routines.
[[file:tests/test-vm.c]]
**** TODO Test vm_print_all
**** TODO Test vm_execute
**** TODO Test vm_execute_all
**** TODO Test vm_copy_program
**** TODO Test vm_write_program
**** TODO Test vm_read_program
** TODO [#C] Optimise processor for parse results
[[file:src/parser.c::perr_t process_presults(pres_t *results, size_t
results_size, buffer_t *buffer,]]
** DONE Implement a tagging scheme :FEATURE:
A tagging scheme allows us to implement a variety of types for data in
the virtual machine.  A big problem with, say, a pointer tagging
scheme is that we must waste a ton of space in the assembler for small
types.  For example, a boolean needs only a bit to work but we must
force it to waste 63 bits of extra space just to make it uniform.  A
character (at least the C style ones) only need a byte, but we'll need
to encode 7 waste bytes to make it uniform.

Here's a really simple scheme:
+ A "tag" byte which tells the interpreter what type of data and how
  many bytes of data the subsequent operand is
+ The payload

A byte is over 256 values: I don't think we're going to need 256 types
but I don't want to have to do some weird "nibble reading" and it
allows us to reserve a ton of types or special things for future me to
use.
** DONE Rewrite simple execution control (OP_JUMP) [100%] :PARSER:BYTECODE:
Previous implementation had separate instructions for jumping
relatively and to a label, and an instruction for instantiating a
label.  This adds some bloat to the runtime in managing labels (as
well as possible error conditions on the label stack) and the parser
in distinguishing between jumps.  One pro is that this makes the
parser "one-pass" i.e. only requires one run through source code to
generate all the necessary instructions.

Instead, how about just implementing one *absolute* jump and reworking
the parser to instead /rewrite/ the source code to use it?  This means
we'd have to do /multiple passes/ on the parsed data to figure out
where labels are and rewrite the various jumps to use absolute
pointers.
*** DONE Rewrite parser for label
[[file:src/parser.c::else if (memcmp(buf->data + buf->cur, "label", 5)
== 0)]]
*** DONE Rewrite parser for jump
[[file:src/parser.c::else if (memcmp(buf->data + buf->cur, "jmp", 3)
== 0)]]

